{
  "version": 3,
  "file": "cli.js",
  "sourceRoot": "",
  "sources": [
    "cli.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "'use strict'\n\n# Import/Require the \"argparse\" module that provides an easy to use command line argument parser\nargparse = require('argparse')\n\n# Returns the ANSI escape code for ANSI color code <code>\nansi_color_code = (code) ->\n\t\"\\x1b[#{code}m\"\n\n# Returns true if the passed argument <value> is neither null nor undefined\nis_valid_value = (value) ->\n\t((value isnt undefined) and (value isnt null))\n\n# Returns the first value in <values...> that is neither null nor undefined\nfirst_valid_value = (values...) ->\n\tfor value in values\n\t\tif is_valid_value(value)\n\t\t\treturn value\n\treturn\n\n# Colorize string <string> by ANSI-escaping it with ANSI sequence <color>\nansi_colorize = (string, code) ->\n\tcode = first_valid_value(code, 31)\n\t\"#{ansi_color_code(code)}#{string}#{ansi_color_code(0)}\"\n\n# Returns a Promise that resolves after <milliseconds> milliseconds (defaults to 0)\ndelay = (milliseconds) ->\n\tmilliseconds = first_valid_value(milliseconds, 0)\n\tnew Promise (resolve, reject) ->\n\t\tsetTimeout ->\n\t\t\t\tresolve()\n\t\t\t, milliseconds\n\n# Exit the current process with status code <status_code>. \"noble\" (the Bluetooth LE library being used) currently requires so: https://github.com/noble/noble/issues/299\nexit_process = (status_code) ->\n\tstatus_code = first_valid_value(status_code, 0)\n\tprocess.exit(status_code)\n\n# Checks if <value> is an array. Returns true if it is an array, false otherwise\nis_array = (value) ->\n\tArray.isArray(value)\n\n# Returns a function with argument <value> that returns true if <value> is of type <type_string>, false otherwise\nis_of_type = (type_string) ->\n\t(value) ->\n\t\t(typeof(value) is type_string)\n\n# Returns true if the passed argument <value> is a string, false otherwise\nis_string = is_of_type('string')\n\n# Process one or more <input_sources...>, and call <input_handler> for each input string, passing the input strings as argument to <input_handler>. Every input source must either be a string, an array of strings, or a Readable stream like process.stdin\nprocess_input = (input_sources..., input_handler) ->\n\tnew Promise (resolve, reject) ->\n\t\tinput_source = input_sources.find (input_source) ->\n\t\t\t(is_valid_value(input_source) and (not is_array(input_source) or (input_source.length > 0)))\n\t\tif is_string(input_source)\n\t\t\tinput_source = [input_source]\n\t\tif is_array(input_source)\n\t\t\thandle_next = ->\n\t\t\t\tif (input_source.length is 0)\n\t\t\t\t\tresolve()\n\t\t\t\telse\n\t\t\t\t\tPromise.resolve(input_handler(input_source.shift()))\n\t\t\t\t\t.then ->\n\t\t\t\t\t\thandle_next()\n\t\t\t\treturn\n\t\t\thandle_next()\n\t\telse\n\t\t\tinput_strings = []\n\t\t\tclosed = false\n\t\t\tinactive = true\n\t\t\thandle_next = ->\n\t\t\t\tif inactive\n\t\t\t\t\tif (input_strings.length > 0)\n\t\t\t\t\t\tinactive = false\n\t\t\t\t\t\tPromise.resolve(input_handler(input_strings.shift()))\n\t\t\t\t\t\t.then ->\n\t\t\t\t\t\t\tinactive = true\n\t\t\t\t\t\t\thandle_next()\n\t\t\t\t\telse if closed\n\t\t\t\t\t\tresolve()\n\t\t\t\treturn\n\t\t\t# The input source is expected to be a readable stream; read the stream line by line and pass the stripped lines to the input handler\n\t\t\treadline = require('readline')\n\t\t\treadline_interface = readline.createInterface\n\t\t\t\tinput: input_source\n\t\t\t\toutput: null\n\t\t\treadline_interface.on 'line', (input_line) ->\n\t\t\t\tif (input_strings.push(input_line.trim()) is 1)\n\t\t\t\t\thandle_next()\n\t\t\t\treturn\n\t\t\treadline_interface.on 'close', ->\n\t\t\t\tclosed = true\n\t\t\t\thandle_next()\n\t\t\t\treturn\n\t\treturn\n\n# What this module exports\nmodule.exports =\n\tArgumentParser: argparse.ArgumentParser\n\tansi_colorize: ansi_colorize\n\tdelay: delay\n\texit: exit_process\n\tprocess_input: process_input\n"
  ]
}